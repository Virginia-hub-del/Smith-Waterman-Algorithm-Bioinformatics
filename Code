import numpy as np
import argparse

def create_scoring_matrix(seq1, seq2, match_score=3, mismatch_penalty=-3, gap_penalty=-2):
    M = np.zeros((len(seq1) + 1, len(seq2) + 1), int)
    for i in range(1, len(seq1) + 1):
        for j in range(1, len(seq2) + 1):
            match = M[i-1, j-1] + (match_score if seq1[i-1] == seq2[j-1] else mismatch_penalty)
            insertion = M[i-1, j] + gap_penalty
            deletion = M[i, j-1] + gap_penalty
            M[i, j] = max(match, insertion, deletion, 0)
    return M

def find_all_max_positions(M):
    max_val = np.max(M)
    max_positions = np.argwhere(M == max_val)
    return max_positions

def count_consecutive_matches(align1, align2):
    count = 0
    longest_streak = 0
    for a, b in zip(align1, align2):
        if a == b:
            count += 1
            longest_streak = max(longest_streak, count)
        else:
            count = 0
    return longest_streak

def perform_traceback(M, visited, start_i, start_j, seq1, seq2, match_score=3, mismatch_penalty=-3, gap_penalty=-2):
    i, j = start_i, start_j
    max_score = M[i, j]
    align1, align2, align_coords = [], [], []
    gaps, matches, mismatches = 0, 0, 0

    while M[i, j] > 0:
        align_coords.append((i, j))
        if i > 0 and j > 0 and M[i, j] == M[i-1, j-1] + (match_score if seq1[i-1] == seq2[j-1] else mismatch_penalty):
            align1.append(seq1[i-1])
            align2.append(seq2[j-1])
            if seq1[i-1] == seq2[j-1]:
                matches += 1
            else:
                mismatches += 1
            i -= 1
            j -= 1
        elif i > 0 and M[i, j] == M[i-1, j] + gap_penalty:
            align1.append(seq1[i-1])
            align2.append("-")
            gaps += 1
            i -= 1
        elif j > 0 and M[i, j] == M[i, j-1] + gap_penalty:
            align1.append("-")
            align2.append(seq2[j-1])
            gaps += 1
            j -= 1
        else:
            break

    align1.reverse()
    align2.reverse()

    while align1 and align2 and (align1[-1] == '-' or align2[-1] == '-'):
        align1.pop()
        align2.pop()

    for (i, j) in align_coords:
        visited[i, j] = True

    return ''.join(align1), ''.join(align2), max_score, align_coords, gaps, matches, mismatches

def smith_waterman(seq1, seq2, match_score=3, mismatch_penalty=-3, gap_penalty=-2):
    if not seq1 or not seq2:
        raise ValueError("Input sequences must not be empty")

    M = create_scoring_matrix(seq1, seq2, match_score=match_score, mismatch_penalty=mismatch_penalty, gap_penalty=gap_penalty)
    visited = np.zeros_like(M, bool)
    all_alignments = []
    max_positions = find_all_max_positions(M)

    for pos in max_positions:
        i, j = pos
        if not visited[i, j]:
            align1, align2, max_score, align_coords, gaps, matches, mismatches = perform_traceback(M, visited, i, j, seq1, seq2, match_score, mismatch_penalty, gap_penalty)
            if align1 is not None and max_score > 0:
                longest_match_streak = count_consecutive_matches(align1, align2)
                if longest_match_streak >= 3 and max_score >= 0.6 * np.max(M):
                    all_alignments.append((align1, align2, max_score, longest_match_streak, gaps, matches, mismatches))

    all_alignments = sorted(all_alignments, key=lambda x: x[3], reverse=True)

    for n, x in enumerate(all_alignments):
        print("\nAlignment Number: {}\n".format(n + 1))
        print("Alignment 1:   ", x[0])
        print("               ", ''.join('|' if x[0][i] == x[1][i] else ' ' for i in range(len(x[0]))))
        print("Alignment 2:   ", x[1])
        print("Score:         ", x[2])
        print("Gaps:          ", x[4])
        print("Matches:       ", x[5])
        print("Mismatches:    ", x[6])
        print("Longest Match Streak: ", x[3], "\n")

def main():
    parser = argparse.ArgumentParser(description='Smith-Waterman algorithm for optimal local sequence alignment. Input sequences manually.')
    parser.add_argument('seq1', type=str, help='First sequence, which corresponds to the matrix rows')
    parser.add_argument('seq2', type=str, help='Second sequence, which corresponds to the matrix columns')
    parser.add_argument('-g', '--gap_penalty', type=float, default=-2, help='Scoring value of a gap. Default is -2')
    parser.add_argument('-m', '--match', type=float, default=3, help='Scoring value of a match. Default is 3')
    parser.add_argument('-x', '--mismatch', type=float, default=-3, help='Scoring value of a mismatch. Default is -3')

    args = parser.parse_args()

    smith_waterman(args.seq1, args.seq2, match_score=args.match, mismatch_penalty=args.mismatch, gap_penalty=args.gap_penalty)

if __name__ == '__main__':
    main()
